"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CronosId = exports.CHAIN_INFO = exports.DEFAULT_RPC_URLS = exports.EXPLORER_URLS = exports.CHAIN = exports.ChainName = void 0;
const ethers_1 = require("ethers");
const cronosid_constants_1 = require("./cronosid.constants");
var ChainName;
(function (ChainName) {
    ChainName["CRONOS_EVM"] = "25";
    ChainName["CRONOS_EVM_TESTNET"] = "338";
    ChainName["CRONOS_ZKEVM"] = "388";
    ChainName["CRONOS_ZKEVM_TESTNET"] = "240";
})(ChainName = exports.ChainName || (exports.ChainName = {}));
exports.CHAIN = {
    25: ChainName.CRONOS_EVM,
    338: ChainName.CRONOS_EVM_TESTNET,
    388: ChainName.CRONOS_ZKEVM,
    240: ChainName.CRONOS_ZKEVM_TESTNET,
};
exports.EXPLORER_URLS = {
    [ChainName.CRONOS_EVM]: 'https://explorer-api.cronos.org/mainnet',
    [ChainName.CRONOS_EVM_TESTNET]: 'https://explorer-api.cronos.org/testnet',
    [ChainName.CRONOS_ZKEVM]: 'https://explorer-api.zkevm.cronos.org',
    [ChainName.CRONOS_ZKEVM_TESTNET]: 'https://explorer-api.testnet.zkevm.cronos.org',
};
exports.DEFAULT_RPC_URLS = {
    [ChainName.CRONOS_EVM]: 'https://evm.cronos.org',
    [ChainName.CRONOS_EVM_TESTNET]: 'https://evm-t3.cronos.org',
    [ChainName.CRONOS_ZKEVM]: 'https://mainnet.zkevm.cronos.org',
    [ChainName.CRONOS_ZKEVM_TESTNET]: 'https://testnet.zkevm.cronos.org',
};
exports.CHAIN_INFO = {
    [ChainName.CRONOS_EVM]: {
        id: 25,
        name: ChainName.CRONOS_EVM,
        explorerUrl: exports.EXPLORER_URLS[ChainName.CRONOS_EVM],
        rpc: exports.DEFAULT_RPC_URLS[ChainName.CRONOS_EVM],
    },
    [ChainName.CRONOS_EVM_TESTNET]: {
        id: 338,
        name: ChainName.CRONOS_EVM_TESTNET,
        explorerUrl: exports.EXPLORER_URLS[ChainName.CRONOS_EVM_TESTNET],
        rpc: exports.DEFAULT_RPC_URLS[ChainName.CRONOS_EVM_TESTNET],
    },
    [ChainName.CRONOS_ZKEVM]: {
        id: 388,
        name: ChainName.CRONOS_ZKEVM,
        explorerUrl: exports.EXPLORER_URLS[ChainName.CRONOS_ZKEVM],
        rpc: exports.DEFAULT_RPC_URLS[ChainName.CRONOS_ZKEVM],
    },
    [ChainName.CRONOS_ZKEVM_TESTNET]: {
        id: 240,
        name: ChainName.CRONOS_ZKEVM_TESTNET,
        explorerUrl: exports.EXPLORER_URLS[ChainName.CRONOS_ZKEVM_TESTNET],
        rpc: exports.DEFAULT_RPC_URLS[ChainName.CRONOS_ZKEVM_TESTNET],
    },
};
class CronosId {
    static registryContracts = {
        [ChainName.CRONOS_EVM]: cronosid_constants_1.CRONOSID_EVM_MAINNET_REGISTRY_CONTRACT,
        [ChainName.CRONOS_EVM_TESTNET]: cronosid_constants_1.CRONOSID_EVM_TESTNET_REGISTRY_CONTRACT,
    };
    static isCronosId(name) {
        const lowercaseName = name.toLowerCase();
        const parts = lowercaseName.split('.cro');
        return lowercaseName.endsWith('.cro') && parts[0].length > 0;
    }
    static isSupportedChain(chainId) {
        const chain = exports.CHAIN_INFO[chainId];
        if (!chain) {
            throw new Error(`Chain ${chainId} is not a valid chain`);
        }
        return Object.keys(CronosId.registryContracts).includes(chain.name);
    }
    static async forwardResolve(cronosId, chainId) {
        try {
            const chain = exports.CHAIN_INFO[chainId];
            if (!chain) {
                throw new Error(`Chain ${chainId} is not a valid chain`);
            }
            const registryAddress = CronosId.registryContracts[chain.name];
            if (!registryAddress) {
                throw new Error(`CronosId is not supported on ${chain.name} yet`);
            }
            const provider = new ethers_1.ethers.JsonRpcProvider(chain.rpc);
            const registryContract = new ethers_1.ethers.Contract(registryAddress, cronosid_constants_1.CRONOSID_REGISTRY_CONTRACT_ABI, provider);
            const nameHash = ethers_1.ethers.namehash(cronosId);
            const resolvedAddress = await registryContract['owner'](nameHash);
            if (!resolvedAddress || resolvedAddress === ethers_1.ethers.ZeroAddress) {
                throw new Error(`No address found for ${cronosId}`);
            }
            return resolvedAddress;
        }
        catch (error) {
            throw new Error(`Failed to resolve CronosId ${cronosId}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    static async reverseResolve(address, chain) {
        try {
            const registryAddress = CronosId.registryContracts[chain.name];
            if (!registryAddress) {
                throw new Error(`CronosId is not supported on ${chain.name} yet`);
            }
            const provider = new ethers_1.ethers.JsonRpcProvider(chain.rpc);
            const registryContract = new ethers_1.ethers.Contract(registryAddress, cronosid_constants_1.CRONOSID_REGISTRY_CONTRACT_ABI, provider);
            const reverseDomain = `${address.toLowerCase().substring(2)}.addr.reverse`;
            const nameHash = ethers_1.ethers.namehash(reverseDomain);
            const resolverContractAddress = await registryContract['resolver'](nameHash);
            if (!resolverContractAddress || resolverContractAddress === ethers_1.ethers.ZeroAddress) {
                throw new Error(`No reverse record found for address ${address}`);
            }
            const resolverContract = new ethers_1.ethers.Contract(resolverContractAddress, cronosid_constants_1.CRONOSID_EVM_MAINNET_RESOLVER_CONTRACT_ABI, provider);
            const cronosId = await resolverContract['name'](nameHash);
            if (!cronosId) {
                throw new Error(`No cronosId found for address ${address}`);
            }
            return cronosId;
        }
        catch (error) {
            throw new Error(`Failed to reverse resolve address ${address}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
}
exports.CronosId = CronosId;
